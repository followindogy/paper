\chapter{基于优化CPU和GPU内存交互的设计和实现}
前两章总结了大数据高通量仿真中CPU/GPU异构并行计算的必要性和一些已有的GPU异构编程优化方法，并利用编译
原理中引用-定值链和定值-引用链分析程序中的数据流，介绍了一些适用于一般程序的代码移动优化方法。
程序员只有清楚的了解CPU/GPU的体系结构特点，再根据具体的应用场景设计合适的程序逻辑，选择合适的GPU编程
优化方法才能够编写出充分利用GPU计算性能的程序。本章基于CPU/GPU异构计算的内存隔离特点，结合编译原理中的代码
移动规则新提出了一种通过修改源代码来减少CPU和GPU内存之间数据交换带来的系统消耗的优化方法，并在第四章
通过一些对比实验证明了本文提出的方法确实有优化GPU程序的作用。
\section{迁移数据交换操作}
由于CPU和GPU的内部结构不同，CPU适合处理顺序计算、程序逻辑以及系统IO等任务，而GPU适合处理高度并行的复杂计算任务。
所以在CPU/GPU异构体系结构中运行的程序包含CPU代码、GPU代码以及CPU和GPU的交互代码。
普通的程序逻辑就是CPU代码，CPU和GPU内存之间的数据交换操作就是交互代码，核函数就是由GPU代码组成的。
CPU内存和GPU内存是隔离的，运行CPU代码时我们把需要的所有数据拷贝到GPU内存中，同样地运行GPU代码时，我们需要把所有数据拷贝
到GPU内存中。所以GPU程序中每一次核函数的调用，通常会在CPU内存和GPU内存之间进行两次数据交换。核函数执行之前，
CPU和GPU执行相应的交互代码API(CudaMalloc、CudaMemcpy)在GPU内存分配相应大小空间并把核函数需要的数据拷贝到GPU已分配
内存中，这个过程称为数据拷入操作(data copyin)。data copyin操作结束之后，GPU开始启动运行核函数(execution)。
在核函数计算结束之后，我们需要把GPU中计算的结果再次拷贝到CPU内存,称为数据拷出(data copyout)。最后如果GPU
中的变量不会再被后续核函数使用，GPU会释放核函数运行之前分配的GPU内存，这是数据释放操作(data freeing)。
由此可见数据在CPU和GPU内存交换的总时间是由一下三个部分组成的：1.在GPU内存上分配空间等预处理操作时间；
2.数据在PCIe总线上传输时间；3.GPU释放内存等清理操作时间。在核函数比较多的程序中，CPU和GPU之间频繁的数据交换
将成为整个程序的瓶颈，这也是本文优化方法的出发点。本节主要是根据编译原理中代码移动原理迁移GPU程序中核函数的数
据拷贝操作，使原来在程序中固定点执行的数据交换操作可以允许在程序中的一段代码区间执行。
\section{迁移限制}
如上所述，一个核函数的执行被拆分成了四个独立的阶段，数据拷入, 执行, 数据拷出和数据释放。
显然这四个阶段的执行顺序是不能颠倒的，必须按照数据拷入$\rightarrow$执行$\rightarrow$数据拷出$\rightarrow$数据释放
的顺序执行，但是每个操作具体的执行时间确是可以调整的。本文的出发点是优化数据交换操作，所以我们不迁移核函数的执行
操作，只迁移数据拷入，数据拷出，数据释放三个数据交换操作。我们可以把数据拷入操作的交互代码可以看作是CPU代码中对变量的一个引用，可以沿着
代码语句序列向上移动直到程序中某个点改变了该数据，即遇到该变量的定值点就不能再向上移动了，同时我们得保证数据拷入操作
在核函数开始执行之前完成。同样地，我们也可以把交互代码中的数据拷出操作看作是CPU代码中队变量的定值，可以和数据释放操作一起
沿着代码语句序列向下移动，直到程序中出现某条语句引用该变量，即遇到该变量的引用点结束，同时我们必须保证数据
拷出和数据释放操作是在核函数执行完成之后才开始执行的。数据拷出操作之后，为了减少GPU内存的占用，我们将立刻释放相应的GPU内存，
除非该内存数据会在后续的核函数中继续用到我们才选择继续保存，这样可以减少冗余的数据拷贝。
所以在整个数据交换操作的迁移过程中数据依赖性是迁移的前提，
在下面的章节我们将利用编译原理中的引用-定值链和定值-引用链方法来分析
整个程序中的控制流和数据来，得到具体的迁移操作。